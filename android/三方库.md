#### LeakCanary 原理

LeakCanary 是用来检测内存泄露的，最常见的就是生命周期长的引用的生命周期短的对象(静态类引用Activity)，还有非静态内部类和匿名内部类持有外部类引用时等等问题所导致的内存泄露。

LeakCanery 不需要手动初始化，所以肯定是在 ContentProvider 中初始化的，在app在使用的时候如果出现内存泄露并且达到一定数量就会弹出一个通知，点击通知 LeakCanary 就会进行堆栈分析，并且显示出具体的泄露信息，开发者可以通过这些信息来进行分析定位。

LeakCanary 主要是对  Activity ，FragmentAndViewModel 和 RootView 以及 Service 进行监听，初始化完成后会调用各自的 install 方法

- 当监听 Activity 到销毁的时候(使用 Lifecycle 监听)，就会将引用交给 `ReachabilityWatcher` 去处理判断，

-  Fragment中 会先注册 进行监听，然后再 Activity onCreate 的时候注册 Fragment 的生命周期监听，内部调用的是 FragmentManager 进行生命周期的监听，由于一下历史原因，FragmentManager 有三个版本，分别是 app 包下面的，v4 包下的，androidx 包下的，所以对着三个版本进行了分开处理。

    如果版本是 androidX，还会在 Activity和Fragment 中安装 ViewMode 的观察者，安装的时机就是在各自 onCreate 的时候。

    当 Fragment 销毁的时候，会将其中的 view，和 Fragment 交给 `ReachabilityWatcher` 去处理。

-   在 Ativity/Fragment 执行 onCreate 的时候监听 ViewModel，用于监听 ViewModel 是否清除观察者，在调用 install 后会创建一个 ViewModel 并且监听销毁，在销毁的时候通过反射拿到 viewmodelStore 中的 viewModel 数组，然后将每个 viewmodel 交给 ReacabilityWatcher。

- 使用 curtains 库监听所有根 View 的创建和销毁，当窗口类型是 Dialog，Toast，Tooltip 或者未知类型时，创建了一个 Runnable 用于可达性分析，当 View 添加到窗口时，handler 移除 runnable，当 view 移除时，handler 发送 runnable，从而触发 `ReacabilityWatcher` 进行处理。

- 观察 Service 的时候 ，需要反射从 ActivityThread 中获取到 mH(Handler)，并使用自定义的 Callback 替换原有的 mCallback，并缓存原有的 mCallback，从而监听 Service 的停止，当 Handler 接收到的消息是 msg.what == STOP_SERVER  时，表示 service 即将定制，则将其加入到 需要跟踪的集合中。

    最后在反射获取 ActivityManagerService，并使用动态代理去代理 IActivityManager 从而监听该对象的方法调用，如果调用了 serviceDoneExecuting ，证明 service 已经结束，就可以进行可达性追踪，并且从需要跟踪的集合中移除 service 对象。

至于如何判断一个对象是否真的内存泄露，就是通过 ObjectWatcher 的 expectWeaklyReachable方法来实现的。

对于要观察的对象，使用 keyedWeakRefrence 进行关联(初始化时传入弱引用队列)，并将其存入map中，当需要观察的对象被回收后，关联的弱引用就会出现在弱引用队列中。

接着，就会使用 handler 进行五秒的延时再去判断内存泄露,首先会将弱引用队列中的对象推出并从 map 中移除（剩余的就是还没有被回收的）。接着在判断要观察的对象是否存在于map中，不存在则没有泄露，如果存在就可能出现了内存泄露，就会进行进一步的判断，使用 Runtime.geRunTime().gc() 进行垃圾回收，并且延时 100ms 后再次进行判断，若还存在于 map 中，表示已经泄露了，此时就会根据泄露的个数弹出通知或者开始 dump hprof。
