### 如何避免 00M 的产生

#### OOM 的产生

已使用内存 + 新申请的内存 > 可分配的内存，就会出现内存溢出，OOM 几乎覆盖所有的内存区域，通常指堆内存。Native Heap 在物理内存不够用时也会抛出 OOM。

#### OOM 的监控

其实内存溢出的主要原因就是内存泄漏的太多了，导致内存无法被回收，最后可用内存越来越少，然后就溢出了，所以监控的时候主要监控内存溢出就可以了。只要内存没有溢出，那么一般情况下也不会出现内存泄漏；

在开发阶段，可以使用 `LeakCanary` 开源库进行检测

#### 优化 OOM

##### 图片

- 对存在本地的图片进行[压缩](https://tinypng.com/)，太大的可以多压缩几遍

- 尽量根据实际需求选择合适的分辨率

  在资源文件的目录下，根据分辨率来存放图片

- 使用一些优秀的图片加载库，如 Glide 等

- 不适用帧动画，使用代码实现动销

  一个帧动画可以有十几张图片，是非常吃内存的

##### 及时清理缓存，避免内存抖动

对于一些需要释放资源的对象，在使用完成后必须要进行释放资源。

避免内存抖动，意思就是避免重复的创建对象，虽然对象可以被回收，但是如果回收的速度跟不上创建的速度，最后也会内存溢出，场景的就是在自定义 View 的 draw 方法中创建对象，在比较大的循环中创建对象等。

##### 代码优化

- 在数据量小的情况下，考虑使用 ArrayMap/SparseArray，而不是使用传统的 HashMap等数据结构，因为 arrayList 和 SparseArray 占用的内存更少，内部采用了数组的结构，并且 SparseArray 高效的避免了 key 的装箱和拆箱。而 HashMap 需要一个额外的 Entry 对象来完成映射，内部结构是 数组 + 链表，占用的内存较高，但是 HashMap 比较适合大数据和高频繁操作的时候
- 尽量避免使用 ScrollView 来实现列表，因为 ScrollView 内部无法对 view 复用，可以使用 listView，RecyclerView 等。
- 避免在 循环中进行拼接的操作，因为编译局最终会将拼接操作优化为 StringBuilder，如果在循环中大量使用，就会造成大量的内存开销。
- 谨慎使用 static 对象
- 匿名内部类，单例，handler 等造成的内存泄漏
- 优化布局层次，减少内存消耗，
- 避免使用枚举，一个枚举类的大小是 24 字节，而一个普通的 int 只有 4个字节。

### 如何对图片进行缓存

- 图片的加载过程

  现在图片的加载过程都是先从内存中加载图片，如果没有再去本地缓存找，找不到就从网络下载，最后再将图片显示

- 如何对图片进行缓存

  - 网络/磁盘/内存缓存

  - 缓存算法分析

    <img src="https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202203232305355.png" alt="image-20220323230546109" style="zoom:50%;" />

    首先要考虑获取的成本，缓存的对象获取的成本高不高，

    还有缓存的成本，如果缓存的图片/文件非常大，使用率也非常低，那么这种时候是没必要进行缓存的。

    接着就是缓存的价值，也就是命中率，通过时间的推移，来判断命中率如果，如果命中率非常低，那就没必要缓存了。

  - LRU (Least Recently Used) 算法，最近最少使用

    根据历史访问记录来进行淘汰数据，其核心思想是 `如果数据最近被访问过，那么将来被访问的几率也就更高`。最常见的实现就是使用一个链表来缓存数据。

    1，初始化一个链表，

    2，当新的请求进来时，进行缓存，并按照请求的先后顺序，加入到链表中，先加入的在底部，后加入的在顶部，重复的从底部升到顶部。

    也就是说，按照一个先入的原则，一个一个网上加，如果发现重复的，则将其放在最上面。

    最新的数据放在最上面，是应为最新的数据对于其他数据来说可能是热点数据，具有保留时间更久的意义。

    3，当数据放满时，仍然有新的请求进来，且没有重复的，则将底部的淘汰，也就是清除不常访问的数据，在将新的加入到顶部。

  - LFU (Least Frequently Used) 算法，不经常使用的

    如果一个数据在最近一段时间很少被访问到，那么就可以认为他在以后被访问的可能性也很小。因此，当空间满时，最小频率访问的数据首先被淘汰。这就是 LFU 的可惜思想。

    1，初始化一个双向链表

    2，当新的请求进来，对齐进行引用计数 等于1，存入到底部。如果已经存在，则引用计数 + 1，根据引用数量重新排序。

    3，当需要淘汰时，将尾部的淘汰，这也是为什么使用双向链表，因为删除尾部非常简单快捷。




### 如何计算图片占用内存的大小

