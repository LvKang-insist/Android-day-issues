### 如何避免 00M 的产生

#### OOM 的产生

已使用内存 + 新申请的内存 > 可分配的内存，就会出现内存溢出，OOM 几乎覆盖所有的内存区域，通常指堆内存。Native Heap 在物理内存不够用时也会抛出 OOM。

#### OOM 的监控

其实内存溢出的主要原因就是内存泄漏的太多了，导致内存无法被回收，最后可用内存越来越少，然后就溢出了，所以监控的时候主要监控内存溢出就可以了。只要内存没有溢出，那么一般情况下也不会出现内存泄漏；

在开发阶段，可以使用 `LeakCanary` 开源库进行检测

#### 优化 OOM

##### 图片

- 对存在本地的图片进行[压缩](https://tinypng.com/)，太大的可以多压缩几遍

- 尽量根据实际需求选择合适的分辨率

  在资源文件的目录下，根据分辨率来存放图片

- 使用一些优秀的图片加载库，如 Glide 等

- 不适用帧动画，使用代码实现动销

  一个帧动画可以有十几张图片，是非常吃内存的

##### 及时清理缓存，避免内存抖动

对于一些需要释放资源的对象，在使用完成后必须要进行释放资源。

避免内存抖动，意思就是避免重复的创建对象，虽然对象可以被回收，但是如果回收的速度跟不上创建的速度，最后也会内存溢出，场景的就是在自定义 View 的 draw 方法中创建对象，在比较大的循环中创建对象等。

##### 代码优化

- 在数据量小的情况下，考虑使用 ArrayMap/SparseArray，而不是使用传统的 HashMap等数据结构，因为 arrayList 和 SparseArray 占用的内存更少，内部采用了数组的结构，并且 SparseArray 高效的避免了 key 的装箱和拆箱。而 HashMap 需要一个额外的 Entry 对象来完成映射，内部结构是 数组 + 链表，占用的内存较高，但是 HashMap 比较适合大数据和高频繁操作的时候
- 尽量避免使用 ScrollView 来实现列表，因为 ScrollView 内部无法对 view 复用，可以使用 listView，RecyclerView 等。
- 避免在 循环中进行拼接的操作，因为编译局最终会将拼接操作优化为 StringBuilder，如果在循环中大量使用，就会造成大量的内存开销。
- 谨慎使用 static 对象
- 匿名内部类，单例，handler 等造成的内存泄漏
- 优化布局层次，减少内存消耗，
- 避免使用枚举，一个枚举类的大小是 24 字节，而一个普通的 int 只有 4个字节。

### 如何对图片进行缓存

- 图片的加载过程

  现在图片的加载过程都是先从内存中加载图片，如果没有再去本地缓存找，找不到就从网络下载，最后再将图片显示

- 如何对图片进行缓存

  - 网络/磁盘/内存缓存

  - 缓存算法分析

    <img src="https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202203232305355.png" alt="image-20220323230546109" style="zoom:50%;" />

    首先要考虑获取的成本，缓存的对象获取的成本高不高，

    还有缓存的成本，如果缓存的图片/文件非常大，使用率也非常低，那么这种时候是没必要进行缓存的。

    接着就是缓存的价值，也就是命中率，通过时间的推移，来判断命中率如果，如果命中率非常低，那就没必要缓存了。

  - LRU (Least Recently Used) 算法，最近最少使用

    根据历史访问记录来进行淘汰数据，其核心思想是 `如果数据最近被访问过，那么将来被访问的几率也就更高`。最常见的实现就是使用一个链表来缓存数据。

    1，初始化一个链表，

    2，当新的请求进来时，进行缓存，并按照请求的先后顺序，加入到链表中，先加入的在底部，后加入的在顶部，重复的从底部升到顶部。

    也就是说，按照一个先入的原则，一个一个网上加，如果发现重复的，则将其放在最上面。

    最新的数据放在最上面，是应为最新的数据对于其他数据来说可能是热点数据，具有保留时间更久的意义。

    3，当数据放满时，仍然有新的请求进来，且没有重复的，则将底部的淘汰，也就是清除不常访问的数据，在将新的加入到顶部。

  - LFU (Least Frequently Used) 算法，不经常使用的

    如果一个数据在最近一段时间很少被访问到，那么就可以认为他在以后被访问的可能性也很小。因此，当空间满时，最小频率访问的数据首先被淘汰。这就是 LFU 的可惜思想。

    1，初始化一个双向链表

    2，当新的请求进来，对齐进行引用计数 等于1，存入到底部。如果已经存在，则引用计数 + 1，根据引用数量重新排序。

    3，当需要淘汰时，将尾部的淘汰，这也是为什么使用双向链表，因为删除尾部非常简单快捷。




### 如何计算图片占用内存的大小

#### 基础知识

|                   | MDPI    | HDPI    | XHDPI    | XXHDPI    | XXXHDPI   |
| ----------------- | ------- | ------- | -------- | --------- | --------- |
| density(像素密度) | 160     | 240     | 320      | 480       | 640       |
| 分辨率            | 360x640 | 540x960 | 720x1280 | 1080x1920 | 1440x2560 |
| 比例              | 1       | 1.5     | 2        | 3         | 4         |

在 android 中，标准的 dpi = 160，也就是 1 英寸中有 160 个像素。上面表格中的比例就是通过 160 来算出来的。每种密度的比例都是和 150 来进行比较的。

- dp

  设备独立像素值，也就是我们定义在布局文件中的值，但是最终会根据系统计算转为 px。
  $$
  dp=(\frac{dpi}{160(像素/英寸)}) = density(px)
  $$ { }
  假设每英寸的像素是 240像素，也就是 dpi = 240，那么 density 就是 1.5。也就是 dp = 1.5 px。

- density

  像素的密度。常见的取值 1.5，2，3。和标准的 dpi 比例为 (dpi/160px)

- dpi

  手机中每英寸所包含像素点的数量，计算过程如下：

  TIps：屏幕尺寸 5 英寸，分辨率 1280 *720，
  $$
  dpi = (\frac{\sqrt{720^2+1280^2}}{5})
  $$
  在 android 中，如果每英寸的像素为 160，此时 1dp = 1px。160 也是 android 中的一个参考值。公式参考 dp 中的。

- ppi

  每英寸长度内的像素总数

- sp

  缩放无关像素，基本和 dp 一致，其会根据用户字体缩放进行自适应，设置字体大小时使用

- 为啥标准 dpi = 160

  android 中把主流的 dpi 分为了好几个档次，例如 160,240,320,480 等。

  实际开发中，我们经常要对这几个尺寸进行相互转换（例如在某个分辨率下完成设计，然后缩放到其他尺寸微调后输出）一般是按照 dpi 之间的比例来进行缩放的。即  1  :  1.5  ：2  ：3。 也就是 mdpi 到 hdpi 是 1.5 倍，mdpi 到 xhdpi 是 2倍，以此类推。

  也就是说，如果以 160 dpi 为基准，只要尺寸的 dp 是 4 的公倍数，XHDPI 下乘以2，HDPI 下乘以 1.5，LDPI 下乘以 0.75 即可满足所有尺寸下都是整数 pixel。

  


#### 获取 Bitmap 大小

- getByteCount()

  ```java
  public final int getByteCount() {
      if (mRecycled) {
          Log.w(TAG, "Called getByteCount() on a recycle()'d bitmap! "
                  + "This is undefined behavior!");
          return 0;
      }
      // int result permits bitmaps up to 46,340 x 46,340
      return getRowBytes() * getHeight();
  }
  ```

  图片占用内存大小的理论需求值

- getAllocationByteCount()

  ```java
  public final int getAllocationByteCount() {
      if (mRecycled) {
          Log.w(TAG, "Called getAllocationByteCount() on a recycle()'d bitmap! "
                  + "This is undefined behavior!");
          return 0;
      }
      return nativeGetAllocationByteCount(mNativePtr);
  }
  ```

  图片实际占用内存的大小

#### 图片的来源

例：**图片宽 112 像素，高 131 像素，大小 20 kb 左右。**

- Assets 中的资源文件

  ```java
  BitmapFactory.decodeStream(context.getAssets().open("android.png"));
  ```

  例1： 格式为 png 。在 assets 的目录下通过 Bitmap 加载。

  其中加载格式为 ARGB_8888。出来后大小大概是 58 kb 左右。

  计算的方式就是 **112 * 131 * 4** = 58688 。也就是 长乘宽在乘4，至于为什么要乘以四，因为格式是 ARGB_8888，每个像素点有四个字节，后面四个8表示8个比特，8个比特就是一个字节。一共四个字节。

  例2：上面图片，格式为 jpg。

  需要注意的是 jpg 的图片没有 Alpha 通道，也就是说图片不会透明。所以采用 ARGB_8888 加载后前面的 A 是没有啥用的。

  所以需要采用 RGB_565 的格式来加载图片。计算的方式就是 112 * 131 * 2 = 29344 ，565 刚好是两个字节。代码如下：

  ```java
  BitmapFactory.Options options = new BitmapFactory.Options();
  options.inPreferredConfig = Bitmap.Config.RGB_565;
  BitmapFactory.decodeStream(context.getAssets().open("android.png"),options);
  ```

  如果将 png 的图片使用 RGB_565 格式进行加载，加载出的结果上面也会一样，因为少了 Alpah。

- drawable 系列目录中的图片文件，需要注意 dpi 类型的影响

  - hdpi，比例是 1.5

    此时的图片宽度就是 205，高度 240 了。那么这个是如何计算出来的呢？

    (112 / 1.5) *2.75 四舍五入后就等于 205。因为这个目录下的密度比例是 1.5，而手机的密度是 2.75。那么现在要从 1.5 变为 2.75 就需要先除以 1.5，再乘 2.75 了。

    屏幕密度可以通过 `resources.displayMetrics.density` 来获取。

  - xhdpi，比例是 2

    (112 / 2) * 2.75 

  - xxhdpi，比例是 3

    (112  /  3) * 2.75 = 103

  - 其他的都是类似，需要注意的是 drawable 默认比例就是 1，相当于 mdpi。

  所以，drawable 中的图片大小计算方式就是： **图片 /  所在drawable对应dpi的比例 * 屏幕的密度。**

- raw 中的资源，该文件中的资源不会受到任何处理。

