### 使用 V iewPager 需要注意哪些问题

- FragmentPageAdapter

  fragmentPageAdapter 会缓存所有的 fragment，不适合 fragment 多的情况。如果 fragment 中的数据非常大，也不太推荐使用这种。

  这种需要注意的问题就是：

  fragment 的集合不要被比activity 生命周期长的类引用，否则会导致内存泄漏

  fragment 不能太多，数据不能太大，否则就会出现内存溢出

- FragmentStatePagerAdapter

  这种 adapter 在内部会对 fragment 的状态进行缓存。当 Fragment 不可见的时候，就会将 fragment 的实例销毁，当可见的时候就会重新创建 fragment 并且根据缓存的 state 进行恢复。这种情况下占用的内存回小一些。

  但是需要注意一个问题：

  使用 FragmentStatePagerAdapter 在创建 fragmetn 的时候不能将 fragment 放在 list 中，而是应该每次都重新创建：

  ```java
  ///错误写法
  override fun getItem(position: Int): Fragment {
      return tab[position]
  }
  ///正确写法
  override fun getItem(position: Int): Fragment {
      return PageFragment()
  }
  ```

- 白屏问题

  有两种原因：

  1. fragmentManager 使用错了，在 child 中应该使用 childFragmentManager
  2. 就是 上面 FragmentStatePagerAdapter 中的那个问题，因为集合里面的 fragment 生命周期已经已经结束了，再次使用就会造成白屏的问题。

- 动态替换 Fragment

  需要在 adapter 中重写 getITemId 和 getItemPosition 方法

  https://github.com/LvKang-insist/Android-day-issues/issues/5



### Android 中为什么非 UI 线程不能更新 UI 

- UI 线程是什么

  app 启动后，会执行 ActivityThread 中的 main 方法，在 main 方法中会获取创建当前线程的 Lopper，最后调用 loop() 方法开始轮询，这个 lopper 就是主线程的 lopper，线程也被称为 UI 线程。

  也就是说，main 方法中所处的线程就是主线程，也称为 UI 线程，其他的线程就是非 UI 线程了。

- 子线程可以更新 UI 吗？

  答案是可以的。在 `ViewRootImpl` 创建之前去通过子线程更新 UI  是可以的。`ViewRootImpl` 是 View 中的最高层级，属于所有 View 的根。当 View 进行绘制的时候，都会调用拿到 ViewRootImpl 中，在 ViewRoot 中会对线程进行判断，如下所示：

  ```java
      void checkThread() {
          if (mThread != Thread.currentThread()) {
              throw new CalledFromWrongThreadException(
                      "Only the original thread that created a view hierarchy can touch its views.");
          }
      }
  ```

- 主线程如何工作

  mian 线程中主线程的 loop 开始执行后，就会不断地从消息队列中获取数据，然后进行分发。其中 消息队列中的数据时候 Handler 进行发送的。

  整个流程就是：

  1. 创建 Handler，并传入主线程的 Lopper。
  2. 通过 handler.post 向主线程发送消息，该消息会被封装为一个 Message 对象，然后被添加到 MessageQueue 中。在添加到 队列的时候会将 handler 也传到 message 中。
  3. loop 会一直轮询，发现有新的数据后就会取出数据
  4. 最后通过 handler 进行数据的分发。分发的方式有三种，第一种是通过 post 发送的回调，第二种是创建 handler 时传入的 callback，最后一种是重写 handler 方法 handleMessage。

- UI 为什么不设计为线程安全的

  试想一下，UI 线程如果是线程安全的。多个线程同时操作界面的时候，就必须要加锁了。而 UI 具有高频的可变性，频繁的加锁肯定对页面的流畅度有较大的影响。并且 UI 对响应的敏感性要求 UI 的操作必须要高效。为了给 UI 更快的速度和更好的响应时间，所以在更新 UI 的时候，只能由主线程来更新。

- 非 UI 线程一定不能更新 UI 吗？

  不一定，例如 SurfaceView  可以在任何线程更新，在准备要要刷新的数据后，就会调用 `lockCanvas` 对画布上锁，然后会返回一个 `canvas` ，接着就可以进行绘制了，绘制结束后就会调用 `unlockCanvasAndPost` 解锁，并发送出去。

  整个过程运行在任何一个线程都可以，通常来说会对 SurfaceView 创建一个自己特有的线程，专门用来刷新他的内容。这样的话就可以实现一个比较高的帧率，因为它绘制的时间放在了非 UI 线程里面，非 UI 线程绘制完了就会发送给 UI 线程进行显示。整个过程中 UI 线程的压力就会小很多

### Handler 发送消息的 delay 可靠吗

不可靠。如果队列中任务太多，或者主线程任务太重，就会导致卡顿。

```java
boolean enqueueMessage(Message msg, long when) {
	//....
    Message p = mMessages;
    boolean needWake;
    if (p == null || when == 0 || when < p.when) {
    	// 插入到最开始
    } else {
    	//插入到对应的位置
    }
    if (needWake) {
 	   nativeWake(mPtr);//唤醒阻塞的loop
    }
	//....
}
```

```java
Message next() {
    // Return here if the message loop has already quit and been disposed.
    for (;;) {
        nativePollOnce(ptr, nextPollTimeoutMillis);
        synchronized (this) {
            Message msg = mMessages;
            if (msg != null) {
                if (now < msg.when) {
                    // 计算需要等待的时间，在下一次for循环的时候进行阻塞，然后在执行
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                 
                    return msg;
                }
            } 

}
```

整个流程如下：

- 发送：通过 handler 发送消息后，会到 enqueueMessage 方法中将消息添加到 队列中，然后就会通过调用 底层的 wake 方法将正在阻塞的 loop 唤醒，
- 接收：loop 方法中会通过 messageQueue.next() 方法获取下一个任务，如果没有获取到，就会被 `nativePollOnce` 方法阻塞。当阻塞被唤起后，在 next 方法中就会从队列中获取到 message。然后会对 message 进行判断，如果有延时，就会通过 `nativePollOnce` 方法按照延时的时间进行阻塞，最后 next 方法返回 message，由 handler 进行 分发。

队列优化

- 消息复用，使用 Message.obtain() 从消息池中获取空闲的 message 使用
- IdleHandler ，在主线程空闲时执行任务。
- 使用 独享的 Looper，使用自定义的 Lopper，需要注意的是需要手动调用 Lopper.prepare() 创建 Lopper，被创建的 Looper 保存在 ThreadLocal 中， 使用的时候通过 Lopper.myLooper获取，接着手动开启轮询 ，不用的时候调用 quit关闭
