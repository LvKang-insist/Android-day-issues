### CPU 架构适配需要注意哪些问题

#### 不同的 CUP 架构之前兼容性如何

cpu 的架构有 ：x86，x86_64，arm64_v8a，armeabi-v7a，armeabi。

<img src="https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202203091753037.png" alt="image-20220309175321982" style="zoom:50%;" />

兼容性如上所示，armeabi 可以兼容其他的，x86_64 兼容 x86，arm64-v8a 兼容 v7a。

#### Native 库加载

如果有一个在 arm64-v8a 的手机上运行的 app，在加载 so 的时候，它会优先去选择自己对应的 so 库，如下图所示：

<img src="https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202203091758563.png" alt="image-20220309175828517" style="zoom: 50%;" />

如果找不到 v8a,就会继续寻找自己兼容的架构，如 v7a。

- 兼容模式运行的一些问题

  - 兼容模式运行的 native 库无法获得最好的性能

    所以 x86 电脑上运行 arm 的虚拟机会很慢

  - 兼容模式容易出现一些难以排查的问题

  - 系统优先加载对应架构目录下的 so 库

- SDK 开发者应当提供哪些 so 库

  应该结合目标的群体提供合适的架构。

  有些时候在 lib 目录下只提供一个 v7a 的目录，然后将 v8a 的 so 库也放进去，因为有些 so 可能适合在 v7a 上运行，而有些适合在 v8a 上运行。这种情况下又不想去提供两套架构的so库，就可以这么干。微信就是这样做的。

  还有就是通过线上监控的反馈，来分析该为哪些 so 提供 v8a 的版本等。

  动态从云端加载 so 库

- 优化 so 体积

  - 默认隐藏所有符号，只公开必要的

    - -fvisibility = hidden

  - 禁用 C++ Exception & RTTI

    - -fno -exceptions -fno -rtti

  - 不要使用 iostream，应优先使用 Android Log

  - 使用 gc -sections 去除无用代码

    - LOCAL_CFLAGS += ffuncation-sections -fdata-sections
    - LOCAL_LDFLAGS += -WL, --gc-sections

  - 构建时分包

    可以根据 cpu 的架构打出 n 个包，然后通过应用商场按照 CUP 架构分发安装包即可。

#### SDK 开发者需要注意什么

- 尽量不在 Native 层开发，降低问题跟踪维护成功
- 尽量优化 Native 库的体积，降低开发者使用的成本
- 必须提供完整的 CPU 架构依赖



