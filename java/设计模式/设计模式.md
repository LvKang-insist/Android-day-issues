### 工厂模式

**工厂模式的目的是为了将创建对象的过程隐蔽起来，从而达到更高的灵活性，**工厂模式分为三种：简单工厂，工厂方法，抽象工厂模式。

简单工厂：定义一个接口，让具体的产品实现该接口，在创建一个工厂类，将创建产品的细节隐藏，根据传入的 type 来确定创建那个产品对象，最后返回接口类型即可。 **该模式提供了专门用于创建对象的工厂，将对象的创建和使用进行分离，客户端不需要知道如何创建，只需要进行使用即可。**

工厂方法：将简单工厂进行抽象化，定义个抽象/接口产品类，让具体的产品继承自抽象类即可，其次是定义工厂接口，所有工厂必须继承自该接口，然后再实现创建产品的方法即可。**工厂方法模式将工厂进行抽象，每种产品都对应了一个工厂，当我们选择某个工厂，对应的产品也就确定了，并且扩展的时候不用修改原本的代码。这种缺点在于每个产品都需要增加一个具体的产品类和工厂类，产品过多，就会导致工厂特别多，增加了系统的复杂度。**

抽象工厂：在工厂方法中，每个工厂对应一个产品，但是有时候需要一个工厂能够提供多个产品对象，这种情况就可以使用抽象工厂。抽象工厂就是创建一个抽象工厂类，以便可以实现一组特定的对象，具体的工厂继承自抽象工厂，并实现这些创建对象的方法，然后创建对应的产品即可。



### 观察者模式

观察者模式又称之为发布-订阅模式，发布者负责发送，订阅者负责消费，它定义了对象之间的一种一对多的依赖关系，当一个对象发生改变后，所有依赖他的对象都会收到通知。

优点：解除观察者和发布者的耦合，让耦合的双方都依赖于抽象，而不是依赖于具体

​			易于扩展，新增观察者非常方便，无需修改原有代码

缺点：依赖关系没有完全解除，双方依然依赖于抽象

​			观察者如果太多，调试会比较复杂，并且一般通知观察者的时候是顺序执行的，如果一个观察者卡顿，会影响整体的效率，这种情况下一般可以采用异步来实现

​			可能会引起多余的数据通知

